<|im_start|>user
You are to implement a simple key-value store in Python that interacts via standard input and output. The key-value store should support the following commands, one per line:

- SET key value: Sets the value for the given key.
- GET key: Retrieves and prints the value associated with the key, or prints None if the key does not exist.
- DELETE key: Deletes the key from the store if it exists.
- SAVE filename: Saves the current key-value store to a given filename in JSON format.
- LOAD filename: Loads the key-value store from a given filename (overwriting the current store). If the file does not exist, clears the store.
- EXIT: Terminates the program.

Input:
Lines of commands described above.

Output:
For GET, output the value or None. For other commands, output nothing.

Example Input:
SET name Alice
GET name
DELETE name
GET name
EXIT

Example Output:
Alice
None<|im_end|>
<|im_start|>assistant
<think>
We are going to implement a simple key-value store in Python.
 We'll use a dictionary to store the key-value pairs.
 Steps:
 1. Initialize an empty dictionary for the store.
 2. We'll read lines from standard input until we get the command "EXIT".
 3. For each line, we split it to get the command and the arguments.

 Important: The commands are one per line.

 We have to handle:
   - SET: split the line -> [cmd, key, value] (note: value might have spaces? but the problem says "key value", so we assume value is a single word? 
        However, the problem says: "one per line" and the example has single words. But to be safe, we can note that the problem says "key value" meaning the value is a single token? 
        But the problem does not specify that the value is a single token. However, the example input uses single words.

 Let's re-read: The problem says "SET key value", so the value is a string that might have spaces? Actually, the problem does not specify.

 But note: the problem says "interacts via standard input and output", and the example input uses single words.

 However, the problem says: "For GET, output the value or None". So the value we store should be a string.

 Approach for SET: 
   We can split the line by space, and the first token is "SET", then the next token is the key, and the rest of the tokens form the value? 
   But the problem says: "SET key value" -> meaning the value is one token? 

 Let me see the example: "SET name Alice" -> so value is "Alice", which is one token.

 However, the problem does not specify that the value is a single token. But the problem says: "key value" (with a space) so it's two tokens.

 But what if the value has space? The problem does not specify. We have to design for the requirement.

 Since the problem says: "one per line", and the example uses single words, and the problem is simple, we assume that the value is a single token (without spaces).

 However, to be safe, the problem statement says: "key value" (meaning the value is a single string that we get as the next non-command part). 

 But the problem does not specify that the value cannot have spaces. So we have to be cautious.

 Let's look at the problem again: "The key-value store should support the following commands, one per line"

 And the example input: 
   SET name Alice
   GET name
   DELETE name
   GET name
   EXIT

 So the value in SET is a single word.

 However, the problem says: "output the value" for GET. So we output the string.

 Since the problem is for a simple key-value store and the example uses single words, we'll assume that the value is a single token (without spaces).

 But note: the problem says "value" (so it's a string) and if the user inputs a space, then we have to capture the entire rest of the line after the key.

 How about: 
   For SET: 
        line = input().strip()
        parts = line.split(maxsplit=1)   # split into at most two parts: [cmd, rest]
        if parts[0] == 'SET':
            key = parts[1].split()[0]   # but wait, what if the value has space? 

 Alternatively, we can do:
        tokens = line.split()
        if tokens[0] == 'SET':
            key = tokens[1]
            value = ' '.join(tokens[2:])

 However, the problem says: "key value" (meaning two tokens: key and value) but the value might be multiple tokens? 

 Since the problem does not specify, and to be safe for the problem's simplicity (as it's a simple exercise), I'll assume that the value is a single token (without spaces). 

 But the problem says: "the value" (so it's a string that we store). And the example input uses single words.

 Let me see the problem statement: it says "key value" (with a space) but it doesn't say the value is a single word. However, the problem is from a context that expects single words.

 Since the problem says: "For GET, output the value or None", and the value we store is a string, we can store the entire string that comes after the key (without the command).

 Plan:
   We'll split the line and take the first token as the command.

   For SET:
        tokens = line.split()
        if tokens[0] == 'SET' and len(tokens) >= 2:
            key = tokens[1]
            # the rest of the tokens (from index 2 to end) form the value string
            value = ' '.join(tokens[2:])
            store[key] = value

   Similarly, for other commands, we can do:

   For GET:
        tokens = line.split()
        if tokens[0] == 'GET' and len(tokens) >= 2:
            key = tokens[1]
            if key in store:
                print(store[key])
            else:
                print(None)

   For DELETE:
        tokens = line.split()
        if tokens[0] == 'DELETE' and len(tokens) >= 2:
            key = tokens[1]
            if key in store:
                del store[key]

   For SAVE:
        tokens = line.split()
        if tokens[0] == 'SAVE' and len(tokens) >= 2:
            filename = tokens[1]
            # Save the store as JSON to the file
            import json
            with open(filename, 'w') as f:
                json.dump(store, f)

   For LOAD:
        tokens = line.split()
        if tokens[0] == 'LOAD' and len(tokens) >= 2:
            filename = tokens[1]
            try:
                with open(filename, 'r') as f:
                    store = json.load(f)
            except FileNotFoundError:
                # if the file doesn't exist, clear the store (so we set store to empty dict)
                store = {}
            # But note: the problem says "overwriting the current store", so we assign the new store to our current store
            # However, we are in the loop and we want to update the global store? 
            # We have to be cautious: we are storing the store in a variable (let's call it `store`). 
            # So we do: store = the loaded dict

   For EXIT: break out of the loop.

 However, note: the problem says "If the file does not exist, clears the store". So we do:
        if the file doesn't exist, then we set store = {} (an empty dict) and then continue.

 But in the LOAD command, we do:
        try:
            with open(filename, 'r') as f:
                store = json.load(f)
        except:
            store = {}

 However, the problem says: "overwriting the current store", so we do:

        We'll have a global store (a dictionary) that we update.

 Implementation:

   We'll create a dictionary `store` at the beginning.

   Steps:
      import json

      store = {}

      while True:
          line = input().strip()
          if not line:
              continue   # skip empty lines? but the problem says one command per line, so probably no empty lines. But to be safe.

          tokens = line.split()
          cmd = tokens[0]

          if cmd == 'SET':
              if len(tokens) < 3:
                  # invalid command? but problem says one per line as described. We assume valid input.
                  pass
              else:
                  key = tokens[1]
                  value = ' '.join(tokens[2:])
                  store[key] = value

          elif cmd == 'GET':
              if len(tokens) < 2:
                  pass
              else:
                  key = tokens[1]
                  if key in store:
                      print(store[key])
                  else:
                      print(None)

          elif cmd == 'DELETE':
              if len(tokens) < 2:
                  pass
              else:
                  key = tokens[1]
                  if key in store:
                      del store[key]

          elif cmd == 'SAVE':
              if len(tokens) < 2:
                  pass
              else:
                  filename = tokens[1]
                  with open(filename, 'w') as f:
                      json.dump(store, f)

          elif cmd == 'LOAD':
              if len(tokens) < 2:
                  pass
              else:
                  filename = tokens[1]
                  try:
                      with open(filename, 'r') as f:
                          store = json.load(f)
                  except FileNotFoundError:
                      store = {}   # clear the store
                  # Note: if there's an exception other than FileNotFoundError, we don't want to crash? 
                  # The problem says: if the file does not exist -> clear. So we only clear for FileNotFoundError.
                  # But what about other exceptions? We'll assume the problem doesn't have them.

          elif cmd == 'EXIT':
              break

 But note: the problem says "For other commands, output nothing". So we don't print anything for SET, DELETE, SAVE, LOAD.

 However, what if the command is invalid? The problem says the input is one of the commands. So we assume valid input.

 But to be safe, we can skip invalid commands (do nothing).

 Let's code accordingly.

 Important: We must import json at the top.

 However, note: the problem says "Saves the current key-value store to a given filename in JSON format". We are using json.dump.

 Also, for LOAD: we load the entire store as a dictionary.

 But note: the problem says "overwriting the current store". So we are replacing the current store with the one loaded.

 We'll do:

   store = {}   # initial store

   Then in LOAD, we do: store = json.load(f)   [if exists] or store = {} [if not exists]

 But note: the problem says "If the file does not exist, clears the store". So we set store to an empty dict.

 However, what if the file exists but is not a valid JSON? Then we get an exception. The problem doesn't specify, but we assume valid JSON.

 We'll do minimal error handling for the problem.

 Steps:

   We'll import json.

   We'll have a loop that reads from stdin until "EXIT".

   We output for GET only.

 Let's write the code accordingly.

 Note: The problem says "interacts via standard input and output", so we use input() and print().

 Example: 
   Input: "SET name Alice" -> store['name'] = 'Alice'
   Input: "GET name" -> prints 'Alice'
   Input: "DELETE name" -> deletes 'name'
   Input: "GET name" -> prints None

 Implementation:

   We'll do:

      import json

      store = {}

      while True:
          try:
              line = input().strip()
          except EOFError:
              break

          if not line:
              continue

          tokens = line.split(maxsplit=1)  # We use maxsplit=1 to split the command and the rest (for SET and LOAD) but note: for SET we want the value to be the rest of the line.

          However, note: the problem says one command per line. We'll split the line into tokens.

          Actually, for SET, we have at least 2 tokens: ['SET', 'key', ...] but we want the value to be the entire rest of the line (so we do split with maxsplit=1 for the command and the rest).

          Alternatively, we can do:

            cmd = tokens[0]
            if cmd == 'SET':
                # tokens[1] is the key, and tokens[2:] is the value? but we don't want to split the value into tokens? 
                # Instead, we can do: 
                #   key = tokens[1]
                #   value = line[len(cmd)+1:].strip()   # but this is messy.

          Let me do:

            tokens = line.split(maxsplit=1)   # This splits the line into two parts: [command, rest] (if there is a space after the command)

          Why maxsplit=1? Because for SET, the value might have spaces, so we want to take the rest of the line as the value.

          Example: 
            line = "SET name Alice" -> tokens = ['SET', 'name Alice'] 
            Then we can do: 
                key = tokens[1].split()[0]   -> but that's not what we want.

          Alternatively, we can do without maxsplit=1 and then for SET we take the first token as command, second as key, and the rest as value.

          I think the problem expects the value to be a single token? But the problem says "value" (so it's a string). 

          Given the problem's simplicity, and the example, we'll assume the value is a single token (without spaces). 

          But to be safe for the problem (and since the problem says "key value", meaning two tokens), we'll do:

            tokens = line.split()
            cmd = tokens[0]

          and then:

            if cmd == 'SET':
                if len(tokens) < 2: 
                    continue
                key = tokens[1]
                value = tokens[2] if len(tokens) >= 3 else ''   # but the problem says "value", so we assume at least 3 tokens? 

          However, the problem says: "SET key value" -> so there should be at least 3 tokens? 

          But the problem does not specify that the value is non-empty. So we can have:
                SET key   -> this would be invalid? 

          The problem says: "one per line" of the commands. So we assume the input is well-formed.

          Since the problem is simple, we'll assume:

            SET: has at least 2 tokens (command and key) and then the value is the next token (if present). But the problem says "value", so we assume there is a value.

          However, the problem says: "the key-value store" so we must have a value.

          So we'll require at least 3 tokens for SET? 

          But the problem says: "SET key value", so the value is provided.

          Let's stick to the problem's example: "SET name Alice" -> 3 tokens.

          We'll do:

            tokens = line.split()

          and then:

            if cmd == 'SET':
                if len(tokens) < 3:
                    # skip? or error? but problem says valid input, so we assume at least 3 tokens.
                    pass
                key = tokens[1]
                value = tokens[2]
                store[key] = value

          Similarly, for others, we assume the tokens are as described.

          Why? Because the problem says: "one per line" of the commands. So the input is well-formed.

          So:

            SET: 3 tokens (command, key, value)
            GET: 2 tokens (command, key)
            DELETE: 2 tokens (command, key)
            SAVE: 2 tokens (command, filename)
            LOAD: 2 tokens (command, filename)
            EXIT: 1 token

          So we can do:

            tokens = line.split()
            cmd = tokens[0]

          and then:

            if cmd == 'SET':
                if len(tokens) < 3:
                    continue
                key = tokens[1]
                value = tokens[2]
                store[key] = value

            elif cmd == 'GET':
                if len(tokens) < 2:
                    continue
                key = tokens[1]
                if key in store:
                    print(store[key])
                else:
                    print(None)

            ... and so on.

          This is simpler and matches the example.

          However, the problem does not specify that the value has no spaces. But the example has no spaces. And the problem says "simple". 

          So we'll assume the value is a single token (without spaces).

          If in the future the problem wants multi-word values, we would have to change. But the problem says "simple".

          We'll go with single token values.

 Let's code accordingly.

 Steps:

   import json

   store = {}

   while True:
        try:
            line = input().strip()
        except EOFError:
            break

        if not line:
            continue

        tokens = line.split()
        cmd = tokens[0]

        if cmd == 'SET':
            if len(tokens) >= 3:
                key = tokens[1]
                value = tokens[2]
                store[key] = value

        elif cmd == 'GET':
            if len(tokens) >= 2:
                key = tokens[1]
                if key in store:
                    print(store[key])
                else:
                    print(None)

        elif cmd == 'DELETE':
            if len(tokens) >= 2:
                key = tokens[1]
                if key in store:
                    del store[key]

        elif cmd == 'SAVE':
            if len(tokens) >= 2:
                filename = tokens[1]
                with open(filename, 'w') as f:
                    json.dump(store, f)

        elif cmd == 'LOAD':
            if len(tokens) >= 2:
                filename = tokens[1]
                try:
                    with open(filename, 'r') as f:
                        # We load the entire JSON file into a dictionary
                        store = json.load(f)
                except FileNotFoundError:
                    store = {}   # clear the store

        elif cmd == 'EXIT':
            break

   End of loop.

 But note: the problem says "If the file does not exist, clears the store". So in LOAD, if the file doesn't exist, we set store = {}.

 However, what if the file exists but is not JSON? Then we get an exception. The problem doesn't specify, so we assume valid JSON.

 We'll do as above.

 Let's test with the example:

   Input: 
        SET name Alice
        GET name
        DELETE name
        GET name
        EXIT

   Steps:

        store = {}
        Line1: "SET name Alice" -> tokens = ['SET','name','Alice'] -> store['name'] = 'Alice'
        Line2: "GET name" -> tokens = ['GET','name'] -> print('Alice')
        Line3: "DELETE name" -> tokens = ['DELETE','name'] -> delete 'name' from store
        Line4: "GET name" -> tokens = ['GET','name'] -> print(None)
        Line5: "EXIT" -> break.

   Output: 
        Alice
        None

   So that matches.

   We'll write the code accordingly.

 Important: We must import json.

 Let's write the code.

 Note: The problem does not specify that the input is from a file, so we use input().

 But note: the problem says "interacts via standard input and output".

 We'll do:

   import json

   store = {}

   while True:
        try:
            line = input().strip()
        except EOFError:
            break

        if not line:
            continue

        tokens = line.split()
        cmd = tokens[0]

        if cmd == 'SET':
            if len(tokens) >= 3:
                key = tokens[1]
                value = tokens[2]
                store[key] = value

        elif cmd == 'GET':
            if len(tokens) >= 2:
                key = tokens[1]
                if key in store:
                    print(store[key])
                else:
                    print(None)

        elif cmd == 'DELETE':
            if len(tokens) >= 2:
                key = tokens[1]
                if key in store:
                    del store[key]

        elif cmd == 'SAVE':
            if len(tokens) >= 2:
                filename = tokens[1]
                with open(filename, 'w') as f:
                    json.dump(store, f)

        elif cmd == 'LOAD':
            if len(tokens) >= 2:
                filename = tokens[1]
                try:
                    with open(filename, 'r') as f:
                        store = json.load(f)
                except FileNotFoundError:
                    store = {}   # clear the store

        elif cmd == 'EXIT':
            break

   This should work.

 However, note: in the LOAD command, we are doing `store = json.load(f)`. This replaces the current store with the loaded one.

   But what if the file is not a JSON? Then we get an exception. The problem says the file is in JSON format, so we assume it is.

   We only handle FileNotFoundError.

   Also, the problem says: "If the file does not exist, clears the store", so we do `store = {}` for FileNotFoundError.

   But note: what if the file exists but is not a JSON? Then we get a JSONDecodeError. The problem doesn't specify, so we assume valid JSON.

   We'll do as above.

 Let's run the example with a LOAD and SAVE to see if it works.

   But the problem doesn't require that.

   We write the code as described.

 One more note: the problem says "output nothing" for other commands. We don't print anything for SET, DELETE, SAVE, LOAD (except the LOAD command if we do the clear, but we don't print anything for the clear, we just set store to {}).

   So we are good.

 Code:
</think>

To solve this problem, we need to implement a simple key-value store in Python that processes commands from standard input and produces the appropriate output for the `GET` command. The key-value store supports several commands: `SET`, `GET`, `DELETE`, `SAVE`, `LOAD`, and `EXIT`. 

### Approach
1. **Initialization**: Start with an empty dictionary to store key-value pairs.
2. **Command Processing**: Read each line of input, split it into tokens, and process the command based on the first token.
3. **Command Handling**:
   - **SET**: Takes a key and a value (both single tokens), stores the key-value pair in the dictionary.
   - **GET**: Retrieves the value for a given key. If the key exists, prints the value; otherwise, prints `None`.
   - **DELETE**: Removes a key from the dictionary if it exists.
   - **SAVE**: Saves the current dictionary to a JSON file specified by the filename.
   - **LOAD**: Loads a dictionary from a JSON file specified by the filename. If the file does not exist, clears the dictionary.
   - **EXIT**: Terminates the program.
4. **Input Handling**: The program reads commands from standard input until it encounters the `EXIT` command.

### Solution Code
```python
import json

def main():
    store = {}
    while True:
        try:
            line = input().strip()
        except EOFError:
            break
        if not line:
            continue
        
        tokens = line.split()
        cmd = tokens[0]
        
        if cmd == 'SET':
            if len(tokens) >= 3:
                key = tokens[1]
                value = tokens[2]
                store[key] = value
                
        elif cmd == 'GET':
            if len(tokens) >= 2:
                key = tokens[1]
                if key in store:
                    print(store[key])
                else:
                    print(None)
                    
        elif cmd == 'DELETE':
            if len(tokens) >= 2:
                key = tokens[1]
                if key in store:
                    del store[key]
                    
        elif cmd == 'SAVE':
            if len(tokens) >= 2:
                filename = tokens[1]
                with open(filename, 'w') as f:
                    json.dump(store, f)
                    
        elif cmd == 'LOAD':
            if len(tokens) >= 2:
                filename = tokens[1]
                try:
                    with open(filename, 'r') as f:
                        store = json.load(f)
                except FileNotFoundError:
                    store = {}
                    
        elif cmd == 'EXIT':
            break

if __name__ == '__main__':
    main()
```

### Explanation
1. **Initialization**: The `store` dictionary is initialized to hold key-value pairs.
2. **Reading Input**: The program reads each line of input, strips any extraneous whitespace, and skips empty lines.
3. **Token Processing**: Each line is split into tokens to identify the command and its arguments.
4. **Command Execution**:
   - **SET**: The second token is the key, and the third token is the value. The key-value pair is added to `store`.
   - **GET**: The second token is the key. If the key exists in `store`, its value is printed; otherwise, `None` is printed.
   - **DELETE**: The second token is the key. If the key exists, it is removed from `store`.
   - **SAVE**: The second token is the filename. The current `store` is saved as a JSON file.
   - **LOAD**: The second token is the filename. The file is loaded into `store` (if it exists); otherwise, `store` is cleared.
   - **EXIT**: The loop terminates, ending the program.
5. **Error Handling**: The program handles `FileNotFoundError` during `LOAD` by clearing `store` if the file does not exist. It also gracefully handles end-of-file (EOF) to exit the loop.

This solution efficiently processes each command as specified, ensuring the key-value store functions correctly with minimal overhead and clear output for the `GET` command. The use of JSON for saving and loading ensures compatibility with standard JSON files.<|im_end|>